"""
End-to-end CRUD flow on a representative entity list. Creates an item, verifies it appears in the list, updates its name, confirms update, then deletes it and ensures it no longer appears.

Generated by Juda AI Test Automation
"""

import os
import time
import uuid
import pytest
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

DEFAULT_TIMEOUT = int(os.getenv('SELENIUM_TIMEOUT', '25'))
BASE_URL = os.getenv('TRIXJO_BASE_URL', 'http://localhost:3000')
LOGIN_PATH = os.getenv('TRIXJO_LOGIN_PATH', '/login')
LIST_PATH = os.getenv('TRIXJO_LIST_PATH', '/items')
CREATE_PATH = os.getenv('TRIXJO_CREATE_PATH', '/items/new')
EMAIL = os.environ.get('TRIXJO_USER_EMAIL')
PASSWORD = os.environ.get('TRIXJO_USER_PASSWORD')

SEL = {
    'login_email': ["[data-testid='login-email']", "input[name='email']", "#email"],
    'login_password': ["[data-testid='login-password']", "input[name='password']", "input[type='password']"],
    'login_submit': ["[data-testid='login-submit']", "button[type='submit']"],
    'new_button': ["[data-testid='create-item']", "a[href$='/items/new']", "button[aria-label='New']"],
    'form_name': ["[data-testid='item-name']", "input[name='name']", "#name"],
    'form_submit': ["[data-testid='save-item']", "button[type='submit']"],
    'edit_button': ["[data-testid='edit-item']", "button[aria-label='Edit']", "a*=Edit"],
    'delete_button': ["[data-testid='delete-item']", "button[aria-label='Delete']", "button*=Delete"],
    'confirm_delete': ["[data-testid='confirm-delete']", "button*=Confirm", "button*=Delete"],
}

@pytest.fixture
def driver():
    opts = Options()
    if os.getenv('HEADLESS', '1') == '1':
        opts.add_argument('--headless=new')
    opts.add_argument('--window-size=1280,900')
    d = webdriver.Chrome(options=opts)
    d.set_page_load_timeout(40)
    yield d
    d.quit()

def wait_css_any(driver, selectors, condition='visible', timeout=DEFAULT_TIMEOUT):
    wait = WebDriverWait(driver, timeout)
    for css in selectors:
        try:
            locator = (By.CSS_SELECTOR, css)
            if condition == 'clickable':
                return wait.until(EC.element_to_be_clickable(locator))
            if condition == 'present':
                return wait.until(EC.presence_of_element_located(locator))
            return wait.until(EC.visibility_of_element_located(locator))
        except Exception:
            continue
    raise AssertionError('None of the selectors were found: ' + ','.join(selectors))

@pytest.mark.skipif(not EMAIL or not PASSWORD, reason='Set TRIXJO_USER_EMAIL and TRIXJO_USER_PASSWORD env vars')
def test_crud_create_update_delete_item(driver):
    # Login
    driver.get(BASE_URL.rstrip('/') + LOGIN_PATH)
    wait_css_any(driver, SEL['login_email']).send_keys(EMAIL)
    wait_css_any(driver, SEL['login_password']).send_keys(PASSWORD)
    wait_css_any(driver, SEL['login_submit'], condition='clickable').click()
    # Navigate to list page
    driver.get(BASE_URL.rstrip('/') + LIST_PATH)
    # Start creation (via list New button or direct create route)
    try:
        wait_css_any(driver, SEL['new_button'], condition='clickable').click()
    except AssertionError:
        driver.get(BASE_URL.rstrip('/') + CREATE_PATH)
    # Fill form and save
    original_name = f"Auto Item {uuid.uuid4().hex[:6]}"
    name_el = wait_css_any(driver, SEL['form_name'])
    name_el.clear(); name_el.send_keys(original_name)
    wait_css_any(driver, SEL['form_submit'], condition='clickable').click()
    # After save, ensure it appears on list or detail
    WebDriverWait(driver, DEFAULT_TIMEOUT).until(lambda d: original_name.lower() in d.page_source.lower())
    # Navigate to the item's detail/edit if not already there
    # Try clicking on the item by link text in list
    try:
        link = WebDriverWait(driver, DEFAULT_TIMEOUT).until(
            EC.element_to_be_clickable((By.XPATH, f"//a[normalize-space(text())='{original_name}']"))
        )
        link.click()
    except Exception:
        pass  # may already be on detail view
    # Click edit
    try:
        wait_css_any(driver, SEL['edit_button'], condition='clickable').click()
    except AssertionError:
        # Some UIs allow inline edit; proceed to attempt to change name field directly
        pass
    # Update name
    updated_name = original_name + ' - updated'
    name_inputs = driver.find_elements(By.CSS_SELECTOR, SEL['form_name'][0]) or \
                  driver.find_elements(By.CSS_SELECTOR, SEL['form_name'][1]) or \
                  driver.find_elements(By.CSS_SELECTOR, SEL['form_name'][2])
    if name_inputs:
        name_inputs[0].clear(); name_inputs[0].send_keys(updated_name)
    else:
        # fallback to XPath search for input by label
        try:
            inp = driver.find_element(By.XPATH, "//label[contains(., 'Name')]/following::input[1]")
            inp.clear(); inp.send_keys(updated_name)
        except Exception:
            pass
    # Save update
    try:
        wait_css_any(driver, SEL['form_submit'], condition='clickable').click()
    except AssertionError:
        # Some UIs auto-save; continue
        pass
    # Verify updated
    WebDriverWait(driver, DEFAULT_TIMEOUT).until(lambda d: updated_name.lower() in d.page_source.lower())
    assert updated_name.lower() in driver.page_source.lower(), 'Updated name not found after save'
    # Delete
    try:
        wait_css_any(driver, SEL['delete_button'], condition='clickable').click()
    except AssertionError:
        # If delete is in overflow menu, attempt to open by text
        try:
            driver.find_element(By.XPATH, "//button[contains(., 'Delete')]" ).click()
        except Exception:
            pass
    # Confirm deletion if modal appears
    try:
        wait_css_any(driver, SEL['confirm_delete'], condition='clickable').click()
    except AssertionError:
        # maybe no confirmation
        pass
    # Verify the item no longer appears
    WebDriverWait(driver, DEFAULT_TIMEOUT).until(lambda d: updated_name.lower() not in d.page_source.lower())
    assert updated_name.lower() not in driver.page_source.lower(), 'Deleted item still present in page source'

